Here are five simple to medium backtracking problems to help you practice:

### 1. **Subsets**

Generate all subsets (combinations of any length) of a given list of numbers.

#### Intuition:

- Each element has two choices: either to be included in a subset or excluded. Using backtracking, we can explore both possibilities.
- Start with an empty list and recursively add each element or skip it.

#### Code:

```python
from typing import List

def subsets(nums: List[int]) -> List[List[int]]:
    result = []

    def backtrack(start: int, path: List[int]):
        result.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()

    backtrack(0, [])
    return result

# Example
print(subsets([1, 2, 3]))
```

### 2. **Combinations**

Find all combinations of `k` numbers out of a list of `n` numbers (combinations of fixed length).

#### Intuition:

- Similar to the subsets problem, but only add to the result when the subset length equals `k`.
- Use backtracking to explore different ways to select `k` elements from the list.

#### Code:

```python
def combine(n: int, k: int) -> List[List[int]]:
    result = []

    def backtrack(start: int, path: List[int]):
        if len(path) == k:
            result.append(path[:])
            return
        for i in range(start, n + 1):
            path.append(i)
            backtrack(i + 1, path)
            path.pop()

    backtrack(1, [])
    return result

# Example
print(combine(4, 2))  # Combinations of 2 numbers out of 1 to 4
```

### 3. **Permutations**

Generate all possible permutations of a list of numbers.

#### Intuition:

- Permutations are generated by swapping elements.
- At each step, pick an element to place at the current position and recursively generate the permutations of the remaining list.

#### Code:

```python
def permute(nums: List[int]) -> List[List[int]]:
    result = []

    def backtrack(path: List[int]):
        if len(path) == len(nums):
            result.append(path[:])
            return
        for num in nums:
            if num not in path:
                path.append(num)
                backtrack(path)
                path.pop()

    backtrack([])
    return result

# Example
print(permute([1, 2, 3]))
```

### 4. **Word Search**

Given a 2D board of letters and a word, determine if the word exists in the board by forming it with adjacent cells.

#### Intuition:

- Use backtracking to explore the board and try to match the word.
- Move in four possible directions (up, down, left, right) and mark cells as visited to avoid revisiting them.

#### Code:

```python
def exist(board: List[List[str]], word: str) -> bool:
    rows, cols = len(board), len(board[0])

    def backtrack(r: int, c: int, index: int) -> bool:
        if index == len(word):
            return True
        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]:
            return False

        temp = board[r][c]
        board[r][c] = '#'  # Mark as visited
        found = (backtrack(r + 1, c, index + 1) or
                 backtrack(r - 1, c, index + 1) or
                 backtrack(r, c + 1, index + 1) or
                 backtrack(r, c - 1, index + 1))
        board[r][c] = temp  # Unmark visited
        return found

    for i in range(rows):
        for j in range(cols):
            if backtrack(i, j, 0):
                return True
    return False

# Example
board = [
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
word = "ABCCED"
print(exist(board, word))  # True
```

### 5. **N-Queens Problem**

Place `n` queens on an `n x n` chessboard such that no two queens attack each other.

#### Intuition:

- Use backtracking to place queens row by row. At each step, check if placing a queen is valid (no two queens can be in the same row, column, or diagonal).
- If a valid configuration is found, move to the next row. If no valid move exists, backtrack and try a different position for the previous queen.

#### Code:

```python
def solveNQueens(n: int) -> List[List[str]]:
    def create_board(state):
        board = []
        for row in state:
            board.append("".join(row))
        return board

    def backtrack(row: int):
        if row == n:
            result.append(create_board(board))
            return

        for col in range(n):
            if is_valid(row, col):
                board[row][col] = 'Q'
                cols.add(col)
                diag1.add(row + col)
                diag2.add(row - col)
                backtrack(row + 1)
                board[row][col] = '.'
                cols.remove(col)
                diag1.remove(row + col)
                diag2.remove(row - col)

    def is_valid(row: int, col: int) -> bool:
        return col not in cols and (row + col) not in diag1 and (row - col) not in diag2

    result = []
    cols, diag1, diag2 = set(), set(), set()
    board = [['.'] * n for _ in range(n)]
    backtrack(0)
    return result

# Example
print(solveNQueens(4))
```

### Summary of Backtracking Problems:

1. **Subsets** – Generate all subsets of a list.
2. **Combinations** – Find combinations of a specific length.
3. **Permutations** – Find all possible orders of a list.
4. **Word Search** – Check if a word can be formed on a grid by adjacent cells.
5. **N-Queens** – Place queens on a chessboard such that no two queens threaten each other.

Each problem uses recursive backtracking to explore possible choices, pruning invalid paths and backtracking when necessary. These examples will help you practice constructing and solving problems using backtracking.
